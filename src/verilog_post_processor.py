import os
import re
class VerilogPostProcessor:

    """post process the verilog file generated by flatten
    """

    def __init__(self,
        flattened_verilog_file_path:str = "",
        processed_verilog_file_path:str = ""):

        if not isinstance(flattened_verilog_file_path, str):
            raise TypeError()
        if not isinstance(processed_verilog_file_path, str):
            raise TypeError()
        if processed_verilog_file_path == "":
            raise ValueError()
        if not os.path.isfile(flattened_verilog_file_path):
            raise FileNotFoundError(f"cannot find flattened verilog file path: "
                                    f"{flattened_verilog_file_path}")

        self.flattened_verilog_file_path = flattened_verilog_file_path
        self.processed_verilog_file_path = processed_verilog_file_path
        self.flattened_lines = []

    def _read_file_lines(self):
        with open(self.flattened_verilog_file_path, 'r') as f:
            self.flattened_lines = f.readlines()
        if len(self.flattened_lines) == 0:
            raise ValueError() 
        print(f"[INFO] finish read from file {self.flattened_verilog_file_path}")
        
    def _convert_module_decl_line(self, module_decl_line:str):
        if not isinstance(module_decl_line, str):
            raise TypeError(f"expected module decl line to have type str, "
                            f"but got type = {type(module_decl_line)}, "
                            f"value = {module_decl_line}")
        if not module_decl_line.endswith(");"):
            raise ValueError(f"unexpected module decl line: {module_decl_line}")
        if not module_decl_line.startswith("module "):
            raise ValueError(f"unexpected module decl line: {module_decl_line}")
        if not module_decl_line.count("(") == 1:
            raise ValueError()
        if not module_decl_line.count(")") == 1:
            raise ValueError()
        
        ports_str = module_decl_line.split("(")[1].split(")")[0]
        ports_l = ports_str.split(",")
        ports_l = [_.strip() for _ in ports_l]
        for p in ports_l:
            if not re.match(r'^\w+$', p):
                raise ValueError(f"Port '{p}' is not a valid word in module declaration: {module_decl_line}")
        
        top_module_name = module_decl_line.split("(")[0].split(" ")[1].strip()
        if not re.match(r'^\w+$', top_module_name):
            raise ValueError()

        new_lines_decl_list = []
        new_lines_decl_list.append(f"module {top_module_name} (")
        for i in range(len(ports_l)):
            if i != len(ports_l) - 1:
                new_lines_decl_list.append(f"  {ports_l[i]},")
            else:
                new_lines_decl_list.append(f"  {ports_l[i]}")
        new_lines_decl_list.append(");\n")

        return new_lines_decl_list

    def _process(self):
        module_decl_line = None
        new_lines_decl_list = []
        input_def_list = []
        output_def_list = []
        reg_def_list = []
        wire_def_list = []
        other_content_list = []
        is_entering_module = False
        is_entering_function = False
        is_entering_module_decl = False
        for fl in self.flattened_lines:
            fl = fl.strip()

            if fl.startswith("function"):
                is_entering_function = True
            elif fl.startswith("endfunction"):
                is_entering_function = False

            if fl.startswith("module "):
                is_entering_module = True
                is_entering_module_decl = True
                module_decl_line = fl            
            elif is_entering_module_decl:
                module_decl_line += fl
                if fl.endswith(");"): 
                    is_entering_module_decl = False
                    new_lines_decl_list = self._convert_module_decl_line(module_decl_line)
            elif fl.startswith("input ") and not is_entering_function:
                if not is_entering_module:
                    raise ValueError()
                if not is_entering_function:
                    input_def_list.append(fl)
            elif fl.startswith("output ") and not is_entering_function:
                if not is_entering_module:
                    raise ValueError()
                if not is_entering_function:
                    output_def_list.append(fl)
            elif fl.startswith("reg "):
                if not is_entering_module:
                    raise ValueError()
                reg_def_list.append(fl)
            elif fl.startswith("wire "):
                if not is_entering_module:
                    raise ValueError()
                wire_def_list.append(fl)
            else:
                if is_entering_module:
                    other_content_list.append(fl)
        new_file_content_list = []
        new_file_content_list += new_lines_decl_list
        new_file_content_list += [""]
        new_file_content_list += input_def_list
        new_file_content_list += output_def_list
        new_file_content_list += ["\n"]
        new_file_content_list += reg_def_list
        new_file_content_list += wire_def_list
        new_file_content_list += ["\n"]
        new_file_content_list += other_content_list
        new_file_content_list += ["\n"]
        print(f"[INFO] finished process")
        with open(self.processed_verilog_file_path, 'w') as f:
            f.write("\n".join(new_file_content_list))
        if not os.path.exists(self.processed_verilog_file_path):
            raise FileNotFoundError()
        print(f"[INFO] write to file {self.processed_verilog_file_path}")

    def process(self):
        self._read_file_lines()

        try:
            self._process()
        except Exception as e:
            print(f"[ERROR] got problem in processing verilog {self.flattened_verilog_file_path}")
            raise e